procedure mod {num1 num2 res}
{
	expression res {num1 - floor(num1 / num2) * num2}
}

% For a given iteration and type of figure, function calculates the angle
procedure calculate_angle {iteration type res_angle}
{
	% 1620 = 360 + (225 + 360 + 315) + 360
	% 1620 = (585) + 360 + 360 + (315)
	if_then_else {type == 1} {
		call mod {iteration 1620 res_angle}
		if_then_else {res_angle < 360 || res_angle > 1620 - 360} {
			if_then_else {res_angle > 1620 - 360} {
				expression res_angle {-(res_angle - (1620 - 360))}
			} { }
		} {
			expression res_angle {359.9}
		}
	} {
	if_then_else {type == 2} {
		call mod {iteration 1620 res_angle}
		if_then_else {res_angle <= 585  || res_angle >= 1620 - 315} {
			expression res_angle {0}
		} {
			if_then_else {res_angle > 585 && res_angle < 585 + 360} {
				expression res_angle {res_angle - 585}
			} {
				expression res_angle {-(res_angle - 585 - 360)}
			}
		}
	} {
		expression tmp {floor(iteration / 360)}
		call mod {tmp 2 tmp}
		call mod {iteration 360 res_angle}
		if_then_else {tmp == 1}
		{
			expression res_angle {-res_angle}	
		} { }
	}
	}
}

procedure draw {x y size ang1 ang2 type}
{
	number type1 3
	number type2 3
	if_then_else {type == 1} {
		expression type1 {1}
		expression type2 {2}
	} { }
	call calculate_angle {ang1 type1 ang1}
	call calculate_angle {ang2 type2 ang2}

	number x1 x
	number y1 y
	point P1 x1 y1

	number x2 x1
	number y2 y1
	expression x2 {x1 + size}
	point P2 x2 y2

	number x3 x1
	number y3 y1
	expression y3 {y1 + size}
	point P3 x3 y3

	number x4 x1
	number y4 y1
	expression x4 {x1 + size}
	expression y4 {y1 + size}
	point P4 x4 y4

	expression xc {x1 + size / 2}
	expression yc {y1 + size / 2}
	point PC xc yc

	if_then_else {ang1 != 0} {
		midpoint PC1 P1 PC
		rotate  P1 PC1 -90 PC
		fillarc PC1 P1 ang1

		midpoint PC4 P4 PC
		rotate P4 PC4 -90 PC
		fillarc PC4 P4 ang1
	} { }
	
	if_then_else {ang2 != 0} {
		midpoint PC2 P2 PC
		rotate P2 PC2 -90 PC
		fillarc PC2 P2 ang2

		midpoint PC3 P3 PC
		rotate P3 PC3 -90 PC
		fillarc PC3 P3 ang2
	} { }
}

background 0 0 0
dim 150 150

point I 0 0 6480 0 % for every step of animation, it increases by 20

number j 1
number tmp 0
number x 85
number y 125

while {j <= 7}
{
	call mod { j 2 tmp }
	number k 0
	number len j
	if_then_else {len > 4}
	{
		expression len {8 - len}
		expression x {x + 20}
	} {
		expression x {x - 20}
	}

	while { k < len }
	{
		getx i1 I
		expression addition {4 * sin(i1 / 20 * 2 * 3.14 / 81)} % 0 -  8pi
		
		if_then_else {tmp == 1}
		{
			expression size {15 + 5 * sin(i1 / 20 * 2 * 3.14 / 81)}
			expression tmpx {x + k * 40 + addition}
			expression i1 {i1 * ceil(j/2) / 4}
			color 135 206 250
			call draw { tmpx y size i1 i1 1 }
		}{
			expression size {15 + 5 * cos( i1 / 20 * 2 * 3.14 / 81)}
			expression tmpx {x + k * 40 - addition}
			expression i1 {4/3 * i1 / j}
			 color 138 43 226
			 call draw { tmpx y size i1 i1 2 }
		}
		
		expression k {k + 1}
	}
	expression j {j + 1}
	expression y {y - 20}
}

animation_frames 324 50



